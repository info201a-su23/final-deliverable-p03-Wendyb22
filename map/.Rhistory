22/73
22/87
87/272
pnorm(4,4.2,0.08)
pnorm(4,4.2,0.08)
100-6
qnorm(0.94,4.2,0.08)
pnorm(4.25,4.2,0.08)
0.08/sqrt(20)
1-pnorm(4.26,4.2,0.0179)
1-pnorm(4.26,4.2,0.08/sqrt(20))
sqrt(49+81)
1-pnorm(0,8,11.40175)
punif(7,0,11)-punif(5,0,11)
1-qunif(0.75,0,11)
qunif(0.75,0,11)
qunif(0.75,0,11)
1.2*7
qunif(0.75,0,11)
1.2*7
32*0.2
0.6*(6/10)
library(knitr)
library(tidyverse)
Iris.df <- read_csv("Iris.csv")
Iris.df$Species <- as.factor(Iris.df$Species)
#
HE.df <- read_csv("HairEyeColor.csv")
HE.df$Sex <- as.factor(HE.df$Sex)
HE.df$Hair <- as.factor(HE.df$Hair)
HE.df$Eye <- as.factor(HE.df$Eye)
#
C.df <- read_csv("Cholesterol.csv")
C.df$Cereal <- as.factor(C.df$Cereal)
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
# Check using t.test
t.test(Iris.df$Sepal.Length, conf.level=0.95)$conf.int
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
numobs<-length(Iris.df$Sepal.Length)
xbar<-mean(Iris.df$Sepal.Length)
sd.x<-sd(Iris.df$Sepal.Length)
tcrit<-qt(0.975,(numobs-1))
ME<-tcrit*sd.x/sqrt(numobs)
LB<-xbar-ME
UB<-xbar+ME
# Check using t.test
t.test(Iris.df$Sepal.Length, conf.level=0.95)$conf.int
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
numobs<-length(Iris.df$Sepal.Length)
xbar<-mean(Iris.df$Sepal.Length)
sd.x<-sd(Iris.df$Sepal.Length)
tcrit<-qt(0.975,(numobs-1))
ME<-tcrit*sd.x/sqrt(numobs)
LB<-xbar-ME
UB<-xbar+ME
# Check using t.test
t.test(Iris.df$Sepal.Length, conf.level=0.95)$conf.int
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
numobs<-length(Iris.df$Sepal.Length)
xbar<-mean(Iris.df$Sepal.Length)
sd.x<-sd(Iris.df$Sepal.Length)
tcrit<-qt(0.975,(numobs-1))
ME<-tcrit*sd.x/sqrt(numobs)
LB<-xbar-ME
UB<-xbar+ME
# Check using t.test
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(numobs<-length(Iris.df$Sepal.Length))
xbar<-mean(Iris.df$Sepal.Length)
sd.x<-sd(Iris.df$Sepal.Length)
tcrit<-qt(0.975,(numobs-1))
ME<-tcrit*sd.x/sqrt(numobs)
LB<-xbar-ME
UB<-xbar+ME
# Check using t.test
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(numobs<-length(Iris.df$Sepal.Length))
(xbar<-mean(Iris.df$Sepal.Length))
(sd.x<-sd(Iris.df$Sepal.Length))
(tcrit<-qt(0.975,(numobs-1)))
(ME<-tcrit*sd.x/sqrt(numobs))
(LB<-xbar-ME)
(UB<-xbar+ME)
# Check using t.test
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(numobs<-length(Iris.df$Sepal.Length))
(xbar<-mean(Iris.df$Sepal.Length))
(sd.x<-sd(Iris.df$Sepal.Length))
(tcrit<-qt(0.975,(numobs-1)))
(ME<-tcrit*sd.x/sqrt(numobs))
(LB<-xbar-ME)
(UB<-xbar+ME)
# Check using t.test
t.test(Iris.df$Sepal.Length, conf.level=0.95)$conf.int
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(numobs<-length(Iris.df$Sepal.Length))
(xbar<-mean(Iris.df$Sepal.Length))
(sd.x<-sd(Iris.df$Sepal.Length))
(tcrit<-qt(0.975,(numobs-1)))
(ME<-tcrit*sd.x/sqrt(numobs))
(LB<-xbar-ME)
(UB<-xbar+ME)
muvir
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
µ_ver <- mean(Iris.Ver$Sepal.Length)
# Check using t.test
t.test(Iris.df$Sepal.Length, conf.level=0.95)$conf.int
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
µ_ver <- mean(Iris.Ver$Sepal.Length)
# Check using t.test
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(µ_ver <- mean(Iris.Ver$Sepal.Length))
# Check using t.test
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(µ_ver <- mean(Iris.Ver$Sepal.Length))
(µ_vir <- mean(Iris.Vir$Sepal.Length))
(sd_vir <- sd(Iris.Vir$Sepal.Length))
# Check using t.test
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(µ_ver <- mean(Iris.Ver$Sepal.Length))
(µ_vir <- mean(Iris.Vir$Sepal.Length))
(sd_vir <- sd(Iris.Vir$Sepal.Length))
# Check using t.test
t.test(Iris.Vir$Sepal.Length, µ = 5.936)
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(numobs <- length(Iris.df$Sepal.Length))
(µ_ver <- mean(Iris.Ver$Sepal.Length))
(µ_vir <- mean(Iris.Vir$Sepal.Length))
(sd_vir <- sd(Iris.Vir$Sepal.Length))
(tcrit <- qt(0.05, (numobs-1)))
# Check using t.test
t.test(Iris.Vir$Sepal.Length, µ = 5.936)
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(numobs <- length(Iris.Vir$Sepal.Length))
(µ_ver <- mean(Iris.Ver$Sepal.Length))
(µ_vir <- mean(Iris.Vir$Sepal.Length))
(sd_vir <- sd(Iris.Vir$Sepal.Length))
(tcrit <- qt(0.05, (numobs-1)))
# Check using t.test
t.test(Iris.Vir$Sepal.Length, µ = 5.936)
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(µ_0 <- mean(Iris.Ver$Sepal.Length))
(xbar <- mean(Iris.Vir$Sepal.Length))
(sd_ver <- sd(Iris.Ver$Sepal.Length))
(t <- (xbar - µ_0)/(sd_ver/sqrt100))
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(µ_0 <- mean(Iris.Ver$Sepal.Length))
(xbar <- mean(Iris.Vir$Sepal.Length))
(sd_ver <- sd(Iris.Ver$Sepal.Length))
(t <- (xbar - µ_0)/(sd_ver/sqrt(100)))
(tcrit <- qt(0.05, (numobs-1)))
# Check using t.test
t.test(Iris.Vir$Sepal.Length, µ = 5.936)
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(numobs <- length(Iris.Vir$Sepal.Length))
(µ_0 <- mean(Iris.Ver$Sepal.Length))
(xbar <- mean(Iris.Vir$Sepal.Length))
(sd_ver <- sd(Iris.Ver$Sepal.Length))
(t <- (xbar - µ_0)/(sd_ver/sqrt(100)))
(tcrit <- qt(0.05, (numobs-1)))
(p-value <- pt(t,(numobs-1)))
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(numobs <- length(Iris.Vir$Sepal.Length))
(µ_0 <- mean(Iris.Ver$Sepal.Length))
(xbar <- mean(Iris.Vir$Sepal.Length))
(sd_ver <- sd(Iris.Ver$Sepal.Length))
(t <- (xbar - µ_0)/(sd_ver/sqrt(100)))
(tcrit <- qt(0.05, (numobs-1)))
(pvalue <- pt(t,(numobs-1)))
# Check using t.test
t.test(Iris.Vir$Sepal.Length, µ = 5.936)
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(numobs <- length(Iris.Vir$Sepal.Length))
(µ_0 <- mean(Iris.Ver$Sepal.Length))
(xbar <- mean(Iris.Vir$Sepal.Length))
(sd_ver <- sd(Iris.Ver$Sepal.Length))
(t <- (xbar - µ_0)/(sd_ver/sqrt(100)))
(tcrit <- qt(0.05, (numobs-1)))
(pvalue <- pt(12.63147,(numobs-1)))
# Check using t.test
t.test(Iris.Vir$Sepal.Length, µ = 5.936)
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(numobs <- length(Iris.Vir$Sepal.Length))
(µ_0 <- mean(Iris.Ver$Sepal.Length))
(xbar <- mean(Iris.Vir$Sepal.Length))
(sd_ver <- sd(Iris.Ver$Sepal.Length))
(t <- (xbar - µ_0)/(sd_ver/sqrt(numobs)))
(tcrit <- qt(0.05, (numobs-1)))
(pvalue <- pt(t,(numobs-1)))
# Check using t.test
t.test(Iris.Vir$Sepal.Length, µ = 5.936)
# Create subsets for the two species
Iris.Vir <- Iris.df %>% filter(Species == "virginica")
Iris.Ver <- Iris.df %>% filter(Species == "versicolor")
# add HT by-hand
(numobs <- length(Iris.Vir$Sepal.Length))
(µ_0 <- mean(Iris.Ver$Sepal.Length))
(xbar <- mean(Iris.Vir$Sepal.Length))
(sd_vir <- sd(Iris.Vir$Sepal.Length))
(t <- (xbar - µ_0)/(sd_vir/sqrt(numobs)))
(tcrit <- qt(0.05, (numobs-1)))
(pvalue <- pt(t,(numobs-1)))
# Check using t.test
t.test(Iris.Vir$Sepal.Length, µ = 5.936)
my_map2
knitr::opts_chunk$set(echo = TRUE)
# After our title and date, we will typically have a setup chunk.  This is what
# tells the program how to weave the chunks of code together in our HTML
# document at the end.  Again, note that we have set include to FALSE which
# means that this chunk of text won't show up in our document.
# Let's test that.  To knit this Markdown document together, click on the "Knit"
# button at the top of the scripting window.  This will open a pop-up that is a
# preview of what your document will look like.
# So far we have only gone through the title and date, but we will look at and
# edit the rest as we proceed through the tutorial.
pal1 <- colorNumeric("Reds", domain = MapData1$HealthOutcomesRank)
library(leaflet)
# Here we will throw back to what we learned in Exercise 1.  This should be
# familiar, so I won't do too much annotating.
setwd("/Users/wendybu/Desktop/geog381/exercise3/Exercise 3")
# Note that you will need to adjust the working directory to wherever you have
# it stored on your computer.
library(sf)
WACensusTracts <- st_read(dsn = "WACensusTracts.shp")
# In this tutorial you will see how to use leaflet and R together.  We have
# already used R in this class, but today we will be expanding what we can
# do in R.  In particular, we will be using R Markdown.  This is an R Markdown
# document.  Markdown is a formatting syntax that will allow us to make HTML,
# PDF, or even Microsoft Word documents.  Instead of working from an R script
# we can format information, maps, and graphs together in a neatly designed
# document.  If you want to, you can make your atlas using Markdown.
# Note that to start we are in a gray box.  This is called a chunk.  If you look
# at the bottom of your scripting / markdown window you'll see that it should say
# Chunk 1: intro at this point.  This is because I set up this chunk (see the
# black text at the start of the gray box, telling it that we are using R, that
# this chunk is called intro, and that we don't want this to show up in our
# published final document.)
# Below this, we have what will start every R Markdown document - a title to
# appear at the top of our page, the output, and a date or subtitle.
# Once we put this all together, we will see the title and date appear at the
# top of our document.
knitr::opts_chunk$set(echo = TRUE)
# After our title and date, we will typically have a setup chunk.  This is what
# tells the program how to weave the chunks of code together in our HTML
# document at the end.  Again, note that we have set include to FALSE which
# means that this chunk of text won't show up in our document.
# Let's test that.  To knit this Markdown document together, click on the "Knit"
# button at the top of the scripting window.  This will open a pop-up that is a
# preview of what your document will look like.
# So far we have only gone through the title and date, but we will look at and
# edit the rest as we proceed through the tutorial.
# Anything we want to add to our HTML file as text, we will put outside of our
# grey boxes (or chunks).
# To Create a heading, we will put two #s ahead of the text that we want to be
# our heading.
# Like when we were using an R script in Exercise 1, we will need to tell the
# computer which libraries we are using (and download any we don't already have
# downloaded).  Below you can see the code for installing leaflet (something
# you will have to do the first time you use it on a new computer, but not after
# that).  To install it, remove the # from the start of the line, run that line,
# and then replace the # (because we don't want it to re-install every time we
# knit the code into an HTML document.)
# install.packages("leaflet")
# Now we can load leaflet and make our first map.  Note that I didn't include
# "include=FALSE" in the code for this chunk, so this will appear on our HTML
# document.  This allows us to document the code we used to make the map.
# Please remove the # from the start of the lines below and then click the "Knit"
# button at the top of your scripting window.
library(leaflet)
a <- leaflet() |>
addTiles() |>
addMarkers(lng=-122.30693, lat=47.65681, popup="UW Geography Department")
a
# Let's break down what we did.  First, we loaded the leaflet library as we did
# in Exercise 1.  Next, we created an item named "a" that is a leaflet map.  The
# "|>" at the end of the line allows us to take the output from that line and
# carry it over to the next line (you'll sometimes also see this as %>% if you
# are using the dplyr library).  The "addTiles" line tells it to use the default
# OpenStreetMap tiles - an open source basemap.  The "addMarkers" line added a
# marker for the coordinates I included and if you click on the marker you'll
# see text that shows "UW Geography Department."
# Now notice that all of this text and your code appears in your HTML document.
# Sometimes you'll want that and at other times you won't.  To hide it, but
# still have the map show up, we can add "echo=FALSE" to our opening chunk
# script (see the example in the chunk below.)
# Here we will throw back to what we learned in Exercise 1.  This should be
# familiar, so I won't do too much annotating.
setwd("/Users/wendybu/Desktop/geog381/exercise3/Exercise 3")
# Note that you will need to adjust the working directory to wherever you have
# it stored on your computer.
library(sf)
WACensusTracts <- st_read(dsn = "WACensusTracts.shp")
# In this tutorial you will see how to use leaflet and R together.  We have
# already used R in this class, but today we will be expanding what we can
# do in R.  In particular, we will be using R Markdown.  This is an R Markdown
# document.  Markdown is a formatting syntax that will allow us to make HTML,
# PDF, or even Microsoft Word documents.  Instead of working from an R script
# we can format information, maps, and graphs together in a neatly designed
# document.  If you want to, you can make your atlas using Markdown.
# Note that to start we are in a gray box.  This is called a chunk.  If you look
# at the bottom of your scripting / markdown window you'll see that it should say
# Chunk 1: intro at this point.  This is because I set up this chunk (see the
# black text at the start of the gray box, telling it that we are using R, that
# this chunk is called intro, and that we don't want this to show up in our
# published final document.)
# Below this, we have what will start every R Markdown document - a title to
# appear at the top of our page, the output, and a date or subtitle.
# Once we put this all together, we will see the title and date appear at the
# top of our document.
knitr::opts_chunk$set(echo = TRUE)
# After our title and date, we will typically have a setup chunk.  This is what
# tells the program how to weave the chunks of code together in our HTML
# document at the end.  Again, note that we have set include to FALSE which
# means that this chunk of text won't show up in our document.
# Let's test that.  To knit this Markdown document together, click on the "Knit"
# button at the top of the scripting window.  This will open a pop-up that is a
# preview of what your document will look like.
# So far we have only gone through the title and date, but we will look at and
# edit the rest as we proceed through the tutorial.
# Anything we want to add to our HTML file as text, we will put outside of our
# grey boxes (or chunks).
# To Create a heading, we will put two #s ahead of the text that we want to be
# our heading.
# Like when we were using an R script in Exercise 1, we will need to tell the
# computer which libraries we are using (and download any we don't already have
# downloaded).  Below you can see the code for installing leaflet (something
# you will have to do the first time you use it on a new computer, but not after
# that).  To install it, remove the # from the start of the line, run that line,
# and then replace the # (because we don't want it to re-install every time we
# knit the code into an HTML document.)
# install.packages("leaflet")
# Now we can load leaflet and make our first map.  Note that I didn't include
# "include=FALSE" in the code for this chunk, so this will appear on our HTML
# document.  This allows us to document the code we used to make the map.
# Please remove the # from the start of the lines below and then click the "Knit"
# button at the top of your scripting window.
library(leaflet)
a <- leaflet() |>
addTiles() |>
addMarkers(lng=-122.30693, lat=47.65681, popup="UW Geography Department")
a
# Let's break down what we did.  First, we loaded the leaflet library as we did
# in Exercise 1.  Next, we created an item named "a" that is a leaflet map.  The
# "|>" at the end of the line allows us to take the output from that line and
# carry it over to the next line (you'll sometimes also see this as %>% if you
# are using the dplyr library).  The "addTiles" line tells it to use the default
# OpenStreetMap tiles - an open source basemap.  The "addMarkers" line added a
# marker for the coordinates I included and if you click on the marker you'll
# see text that shows "UW Geography Department."
# Now notice that all of this text and your code appears in your HTML document.
# Sometimes you'll want that and at other times you won't.  To hide it, but
# still have the map show up, we can add "echo=FALSE" to our opening chunk
# script (see the example in the chunk below.)
# Here we will throw back to what we learned in Exercise 1.  This should be
# familiar, so I won't do too much annotating.
setwd("/Users/wendybu/Desktop/geog381/exercise3/Exercise 3")
# Note that you will need to adjust the working directory to wherever you have
# it stored on your computer.
library(sf)
WACensusTracts <- st_read(dsn = "WACensusTracts.shp")
# Again, we have seen how to do this in Exercise 1.  We will be using the same
# process.
library(readr)
HealthOutcomes <- read_csv("HealthOutcomes.csv",
col_types = cols(HealthOutcomesRank = col_number()))
SocialDeterminants <- read_csv("SocialDeterminants.csv",
col_types = cols(SocialDeterminantsRank = col_number()))
# Run this chunk to bring in the data and then take a look at the HealthData
# dataset.  Note that we have data on the following categories:
# Now we will join our table and shapefile together.  From viewing each, we know
# that they have a matching category called STATE_FIPS, so we will use that for
# our join (and we will need the tidyverse library to do our left_join).
library(tidyverse)
MapData1 <- left_join(WACensusTracts, HealthOutcomes, by = c("FIPS"))
MapData2 <- left_join(WACensusTracts, SocialDeterminants, by = c("FIPS"))
pal1 <- colorNumeric("Reds", domain = MapData1$HealthOutcomesRank)
Map1 <- leaflet(data = MapData1) |>
setView(-121.16, 47.4, 6.8) |>
addTiles() |>
addPolygons(
fillColor = ~pal1(HealthOutcomesRank),
weight = 2,
opacity = 1,
color = "white",
fillOpacity = 0.7
) |>
addLegend(
pal = pal1,
values = ~HealthOutcomesRank,
opacity = 0.7,
title = 'Ranks by Tract',
position = "bottomleft"
)
Map1
pal2 <- colorNumeric("Reds", domain = MapData2$SocialDeterminantsRank)
Map2 <- leaflet(data = MapData2) |>
setView(-122.33, 47.60, 10.5) |>
addTiles() |>
addPolygons(
fillColor = ~pal1(SocialDeterminantsRank),
weight = 2,
opacity = 1,
color = "white",
fillOpacity = 0.7
) |>
addLegend(
pal = pal2,
values = ~SocialDeterminantsRank,
opacity = 0.7,
title = 'Ranks by Tract',
position = "bottomleft"
)
Map2
View(Map1)
shiny::runApp('Desktop/info201/groupproject/vizgunviolence')
runApp('Desktop/info201/groupproject/vizgunviolence')
shiny::runApp('Desktop/info201/groupproject/final-deliverable-p03-Wendyb22/map')
source('Desktop/info201/groupproject/final-deliverable-p03-Wendyb22/map/app.R')
source('Desktop/info201/groupproject/final-deliverable-p03-Wendyb22/map/app.R')
runApp('Desktop/info201/groupproject/final-deliverable-p03-Wendyb22/map')
runApp(Users/wendybu/Desktop/info201/groupproject/final-deliverable-p03-Wendyb22/map)
> runApp('Desktop/info201/groupproject/final-deliverable-p03-Wendyb22/map')
runApp('Desktop/info201/groupproject/final-deliverable-p03-Wendyb22/map')
runApp('Desktop/info201/groupproject/final-deliverable-p03-Wendyb22/map')
runApp('Desktop/info201/groupproject/final-deliverable-p03-Wendyb22/map')
setwd('Desktop/info201/groupproject/final-deliverable-p03-Wendyb22/map')
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
install.packages(plotly)
"plotly"
install.packages('plotly')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
shiny::runApp()
runApp()
